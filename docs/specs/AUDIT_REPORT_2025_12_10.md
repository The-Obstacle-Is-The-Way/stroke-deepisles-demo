# Audit Report: Issue #24 Root Cause & Custom Component Proposal

**Date:** December 10, 2025
**Auditor:** Gemini (Senior CLI Agent)
**Review Scope:** Spec #28, Root Cause Analysis, Codebase Status

## 1. Executive Summary

**Recommendation: GO** - Proceed immediately with Spec #28 (Gradio Custom Component).

My audit confirms your root cause analysis is accurate and your proposed solution is the correct, architecturally supported path. The "hacks" involving `gr.HTML` and `js_on_load` are fundamentally incompatible with Gradio's Svelte-based hydration lifecycle, especially when involving asynchronous module loading (`import()`). Continued attempts to patch `gr.HTML` will likely result in further fragility or failure.

## 2. Validation of Root Cause Analysis

| Claim | Verdict | Evidence/Rationale |
|-------|---------|--------------------|
| **Gradio lacks native WebGL/NIfTI in core** | **CONFIRMED** | Issues #4511 and #7649 closed as "not planned" for core. BUT `gradio-litmodel3d` proves WebGL works via Custom Components. |
| **`gr.HTML` + `import()` breaks hydration** | **CONFIRMED** | `js_on_load` runs during the critical hydration phase. Async operations or unhandled Promise rejections here can hang the entire Gradio app ("Loading..." forever). |
| **HF Spaces CSP blocks CDNs** | **CONFIRMED** | HF Spaces enforces strict CSP. While `custom_http_headers` *can* relax this, it doesn't solve the hydration/execution context issue. |
| **`gr.HTML` strips `<script>`** | **CONFIRMED** | Standard security behavior. The `head=` workaround puts scripts in the global scope, polluting the window object and risking race conditions, which you effectively identified. |

**Key Insight:** The "Loading..." hang isn't just a network error; it's a frontend application state deadlock. Your move to a Custom Component moves the NiiVue initialization into a self-contained Svelte `onMount` lifecycle method, which is the correct place for side effects like WebGL context creation.

## 3. Evaluation of Proposed Solution (Spec #28)

The proposed architecture for `gradio_niivue_viewer` is sound and follows best practices.

*   **Architecture:** Python Backend (data passing) + Svelte Frontend (NiiVue rendering) is the standard pattern.
*   **Reference:** `gradio-litmodel3d` is an excellent precedent. It proves WebGL contexts can be managed within a custom component.
*   **Data Passing:** Reusing the "File URL" optimization (Issue #19) is critical. Passing 65MB+ base64 strings to a custom component would degrade performance; passing `/gradio_api/file=` URLs is efficient.

**Refinements for Implementation:**
*   **Build Tooling:** Ensure you have `node` and `npm` available in your environment, as `gradio cc build` requires them.
*   **Type Safety:** The Svelte code in your spec uses TypeScript (`<script lang="ts">`). Ensure your `tsconfig.json` (generated by `gradio cc`) is configured to handle `niivue` types if available, or add a declaration file.
*   **Fallbacks:** In your Svelte component, explicitly handle the case where WebGL2 context is lost or unavailable, providing a user-friendly error message within the component div, rather than crashing the whole app.

## 4. Alternative Approaches Audit

You correctly dismissed the alternatives:
*   **CSP Header Config:** You *could* edit `README.md` to allow external CDNs (`custom_http_headers`), but this only fixes the *loading* of the script, not the *hydration blocking* caused by `js_on_load`. It's a partial fix that leads to the same deadlock.
*   **Static HTML Space:** Too high effort. Losing Gradio's file/state management would require rewriting the entire backend API.

## 5. Risk Assessment

*   **Component Publishing:** You don't strictly *need* to publish to PyPI to use it. You can install it locally (`pip install -e .`) within your repo, which is faster for iteration.
*   **NiiVue Version:** Ensure the custom component's `package.json` pins the exact version of NiiVue you've been testing with (`0.65.0` or newer) to avoid regressions.

## 6. Conclusion

Your analysis effectively ruled out "easy" hacks. The investment of 2-3 days for a Custom Component is justified and necessary to unblock Feature #24.

**Next Action:** Initialize the custom component immediately.
